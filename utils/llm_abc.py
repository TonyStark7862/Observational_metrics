# utils/llm_abc.py
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Any
import random # For mock implementation

# Assume abc_sql_generator is defined elsewhere and imported, or defined here.
# It MUST return a generated SQL query string.
# Replace this with your actual import or implementation.
def abc_sql_generator(model: str, prompt: str) -> tuple[str, float, int, int]:
    """
    Calls your custom SQL generation function/API.

    Args:
        model: The identifier for the model/method being used.
        prompt: The input prompt string (likely containing question, schema, etc.).

    Returns:
        A tuple containing:
        - generated_sql (str): The SQL query string generated by the custom function/API.
        - execution_time (float): Time taken for the generation in seconds.
        - input_tokens (int): Number of tokens in the input prompt (estimated/actual).
        - output_tokens (int): Number of tokens in the generated SQL (estimated/actual).
    Raises:
        Exception: If the generation process fails.
    """
    # --- Start Mock Implementation (Replace with your actual logic) ---
    print(f"Calling abc_sql_generator for model: {model} with prompt starting: '{prompt[:60]}...'")
    time.sleep(0.2 + random.random() * 0.3) # Simulate generation time

    # Simulate SQL generation based on prompt keywords (very basic example)
    generated_sql = "SELECT 'Error: Could not generate SQL' AS generated_sql;" # Default error
    if "How many customers" in prompt:
         generated_sql = "SELECT COUNT(customer_id) FROM customers;"
    elif "total revenue" in prompt:
         generated_sql = "SELECT SUM(amount) FROM orders WHERE status = 'completed';"
    elif "list products" in prompt:
         generated_sql = "SELECT product_name, price FROM products ORDER BY price DESC LIMIT 5;"
    elif "customer details" in prompt:
         generated_sql = "SELECT name, email, signup_date FROM customers WHERE customer_id = 123;"
    # Simulate occasional failure
    if random.random() < 0.08:
         raise ValueError("Simulated SQL generation error")

    print(f"Generated SQL: {generated_sql}")
    execution_time = 0.25 + random.random() * 0.2
    input_tokens = len(prompt.split()) # Rough estimate
    output_tokens = len(generated_sql.split()) # Rough estimate
    # --- End Mock Implementation ---
    return generated_sql, execution_time, input_tokens, output_tokens

@dataclass
class LLMABCResponse:
    """Data class to hold the response from the abc_sql_generator."""
    generated_sql: str
    latency_seconds: float
    input_tokens: int
    output_tokens: int
    error_msg: Optional[str] = None # Add an error field

def call_abc_generator_with_retry(
    model: str,
    prompt: str,
    max_retries: int = 3,
    base_delay: float = 1.0,
) -> LLMABCResponse:
    """
    Calls the abc_sql_generator function with retry logic.

    Args:
        model: The model identifier to pass to abc_sql_generator.
        prompt: The prompt to pass to abc_sql_generator.
        max_retries: Maximum number of retry attempts.
        base_delay: Initial delay in seconds for retries.

    Returns:
        An LLMABCResponse object containing the results or error information.
    """
    for attempt in range(max_retries):
        try:
            # Call your custom SQL generator
            generated_sql, latency_seconds, input_tokens, output_tokens = abc_sql_generator(
                model=model, prompt=prompt
            )
            # Basic validation: check if it's a non-empty string
            if not isinstance(generated_sql, str) or not generated_sql.strip():
                 raise ValueError("SQL generator returned empty or non-string result.")

            return LLMABCResponse(
                generated_sql=generated_sql,
                latency_seconds=round(latency_seconds, 3),
                input_tokens=input_tokens,
                output_tokens=output_tokens,
                error_msg=None
            )
        except Exception as e:
            error_msg = f"Attempt {attempt + 1} failed: {e}"
            print(error_msg, flush=True)
            if attempt + 1 == max_retries:
                # Return error details on the last attempt
                return LLMABCResponse(
                    generated_sql="", # Return empty SQL on failure
                    latency_seconds=0.0,
                    input_tokens=len(prompt.split()), # Estimate input tokens even on failure
                    output_tokens=0,
                    error_msg=f"SQL Generation failed after {max_retries} attempts: {e}"
                )
            delay = base_delay * (2**attempt)  # Exponential backoff
            print(f"Retrying in {delay:.2f} seconds...", flush=True)
            time.sleep(delay)
    # This part should ideally not be reached if max_retries > 0
    return LLMABCResponse(generated_sql="", latency_seconds=0.0, input_tokens=0, output_tokens=0, error_msg="Max retries exceeded without success.")

